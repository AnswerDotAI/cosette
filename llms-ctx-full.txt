<project title="Claudette" summary="Cosette is a Python library that wraps OpenAI's API to provide a higher-level interface for creating AI applications. It automates common patterns while maintaining full control, offering features like stateful chat, prefill support, image handling, and streamlined tool use.">Things to remember when using Claudette:

- Claudette is designed to work with Claude 3 models (e.g. 'o1-preview', 'o1-mini', 'gpt-4o', 'gpt-4o-mini', 'gpt-4-turbo', 'gpt-4', 'gpt-4-32k', 'gpt-3.5-turbo', 'gpt-3.5-turbo-instruct') and supports multiple providers (OpenAI direct, Azure)
- Use `Chat()` for maintaining conversation state and handling tool interactions
- When using tools, the library automatically handles the request/response loop
- Image support is built in<docs><doc title="README" desc="Quick start guide and overview"># cosette



## Install

``` sh
pip install cosette
```

## Getting started

OpenAI’s Python SDK will automatically be installed with Cosette, if you
don’t already have it.

``` python
from cosette import *
```

Cosette only exports the symbols that are needed to use the library, so
you can use `import *` to import them. Alternatively, just use:

``` python
import cosette
```

…and then add the prefix `cosette.` to any usages of the module.

Cosette provides `models`, which is a list of models currently available
from the SDK.

``` python
models
```

    ('gpt-4o',
     'gpt-4-turbo',
     'gpt-4',
     'gpt-4-32k',
     'gpt-3.5-turbo',
     'gpt-3.5-turbo-instruct')

For these examples, we’ll use GPT-4o.

``` python
model = models[0]
```

## Chat

The main interface to Cosette is the
[`Chat`](https://AnswerDotAI.github.io/cosette/core.html#chat) class,
which provides a stateful interface to the models:

``` python
chat = Chat(model, sp="""You are a helpful and concise assistant.""")
chat("I'm Jeremy")
```

Hi Jeremy! How can I assist you today?

<details>

- id: chatcmpl-9R8Z0uRHgWl7XaV6yJtahVDyDTzMZ
- choices: \[Choice(finish_reason=‘stop’, index=0, logprobs=None,
  message=ChatCompletionMessage(content=‘Hi Jeremy! How can I assist you
  today?’, role=‘assistant’, function_call=None, tool_calls=None))\]
- created: 1716254802
- model: gpt-4o-2024-05-13
- object: chat.completion
- system_fingerprint: fp_729ea513f7
- usage: CompletionUsage(completion_tokens=10, prompt_tokens=21,
  total_tokens=31)

</details>

``` python
r = chat("What's my name?")
r
```

Your name is Jeremy. How can I assist you further?

<details>

- id: chatcmpl-9R8Z1c76TFqYFYjyON08CbkAmjerN
- choices: \[Choice(finish_reason=‘stop’, index=0, logprobs=None,
  message=ChatCompletionMessage(content=‘Your name is Jeremy. How can I
  assist you further?’, role=‘assistant’, function_call=None,
  tool_calls=None))\]
- created: 1716254803
- model: gpt-4o-2024-05-13
- object: chat.completion
- system_fingerprint: fp_729ea513f7
- usage: CompletionUsage(completion_tokens=12, prompt_tokens=43,
  total_tokens=55)

</details>

As you see above, displaying the results of a call in a notebook shows
just the message contents, with the other details hidden behind a
collapsible section. Alternatively you can `print` the details:

``` python
print(r)
```

    ChatCompletion(id='chatcmpl-9R8Z1c76TFqYFYjyON08CbkAmjerN', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='Your name is Jeremy. How can I assist you further?', role='assistant', function_call=None, tool_calls=None))], created=1716254803, model='gpt-4o-2024-05-13', object='chat.completion', system_fingerprint='fp_729ea513f7', usage=In: 43; Out: 12; Total: 55)

You can use `stream=True` to stream the results as soon as they arrive
(although you will only see the gradual generation if you execute the
notebook yourself, of course!)

``` python
for o in chat("What's your name?", stream=True): print(o, end='')
```

    I don't have a personal name, but you can call me Assistant. How can I help you today, Jeremy?

## Tool use

[Tool use](https://docs.openai.com/claude/docs/tool-use) lets the model
use external tools.

We use [docments](https://fastcore.fast.ai/docments.html) to make
defining Python functions as ergonomic as possible. Each parameter (and
the return value) should have a type, and a docments comment with the
description of what it is. As an example we’ll write a simple function
that adds numbers together, and will tell us when it’s being called:

``` python
def sums(
    a:int,  # First thing to sum
    b:int=1 # Second thing to sum
) -> int: # The sum of the inputs
    "Adds a + b."
    print(f"Finding the sum of {a} and {b}")
    return a + b
```

Sometimes the model will say something like “according to the `sums`
tool the answer is” – generally we’d rather it just tells the user the
answer, so we can use a system prompt to help with this:

``` python
sp = "Never mention what tools you use."
```

We’ll get the model to add up some long numbers:

``` python
a,b = 604542,6458932
pr = f"What is {a}+{b}?"
pr
```

    'What is 604542+6458932?'

To use tools, pass a list of them to
[`Chat`](https://AnswerDotAI.github.io/cosette/core.html#chat):

``` python
chat = Chat(model, sp=sp, tools=[sums])
```

Now when we call that with our prompt, the model doesn’t return the
answer, but instead returns a `tool_use` message, which means we have to
call the named tool with the provided parameters:

``` python
r = chat(pr)
r
```

    Finding the sum of 604542 and 6458932

- id: chatcmpl-9R8Z2JNenseQyQoseIs8XNImmy2Bo
- choices: \[Choice(finish_reason=‘tool_calls’, index=0, logprobs=None,
  message=ChatCompletionMessage(content=None, role=‘assistant’,
  function_call=None,
  tool_calls=\[ChatCompletionMessageToolCall(id=‘call_HV4yaZEY1OYK1zYouAcVwfZK’,
  function=Function(arguments=‘{“a”:604542,“b”:6458932}’, name=‘sums’),
  type=‘function’)\]))\]
- created: 1716254804
- model: gpt-4o-2024-05-13
- object: chat.completion
- system_fingerprint: fp_729ea513f7
- usage: CompletionUsage(completion_tokens=21, prompt_tokens=96,
  total_tokens=117)

Cosette handles all that for us – we just have to pass along the
message, and it all happens automatically:

``` python
chat()
```

The sum of 604542 and 6458932 is 7063474.

<details>

- id: chatcmpl-9R8Z4CrFU3zd71acZzdCsQFQDHxp9
- choices: \[Choice(finish_reason=‘stop’, index=0, logprobs=None,
  message=ChatCompletionMessage(content=‘The sum of 604542 and 6458932
  is 7063474.’, role=‘assistant’, function_call=None,
  tool_calls=None))\]
- created: 1716254806
- model: gpt-4o-2024-05-13
- object: chat.completion
- system_fingerprint: fp_729ea513f7
- usage: CompletionUsage(completion_tokens=18, prompt_tokens=128,
  total_tokens=146)

</details>

You can see how many tokens have been used at any time by checking the
`use` property.

``` python
chat.use
```

    In: 224; Out: 39; Total: 263

### Tool loop

We can do everything needed to use tools in a single step, by using
[`Chat.toolloop`](https://AnswerDotAI.github.io/cosette/toolloop.html#chat.toolloop).
This can even call multiple tools as needed solve a problem. For
example, let’s define a tool to handle multiplication:

``` python
def mults(
    a:int,  # First thing to multiply
    b:int=1 # Second thing to multiply
) -> int: # The product of the inputs
    "Multiplies a * b."
    print(f"Finding the product of {a} and {b}")
    return a * b
```

Now with a single call we can calculate `(a+b)*2` – by passing
`show_trace` we can see each response from the model in the process:

``` python
chat = Chat(model, sp=sp, tools=[sums,mults])
pr = f'Calculate ({a}+{b})*2'
pr
```

    'Calculate (604542+6458932)*2'

``` python
def pchoice(r): print(r.choices[0])
```

``` python
r = chat.toolloop(pr, trace_func=pchoice)
```

    Finding the sum of 604542 and 6458932
    Finding the product of 2 and 1
    Choice(finish_reason='tool_calls', index=0, logprobs=None, message=ChatCompletionMessage(content=None, role='assistant', function_call=None, tool_calls=[ChatCompletionMessageToolCall(id='call_OfypQBQoAuIUksucevaxwH5Z', function=Function(arguments='{"a": 604542, "b": 6458932}', name='sums'), type='function'), ChatCompletionMessageToolCall(id='call_yKAL5o96cDef83OFJhDB21MM', function=Function(arguments='{"a": 2}', name='mults'), type='function')]))
    Finding the product of 7063474 and 2
    Choice(finish_reason='tool_calls', index=0, logprobs=None, message=ChatCompletionMessage(content=None, role='assistant', function_call=None, tool_calls=[ChatCompletionMessageToolCall(id='call_Ffye7Tf65CjVjwwx8Sp8031i', function=Function(arguments='{"a":7063474,"b":2}', name='mults'), type='function')]))
    Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='The result of \\((604542 + 6458932) \\times 2\\) is 14,126,948.', role='assistant', function_call=None, tool_calls=None))

OpenAI uses special tags for math equations, which we can replace using
[`wrap_latex`](https://AnswerDotAI.github.io/cosette/core.html#wrap_latex):

``` python
wrap_latex(contents(r))
```

The result of $(604542 + 6458932) \times 2$ is 14,126,948.

## Images

As everyone knows, when testing image APIs you have to use a cute puppy.

``` python
fn = Path('samples/puppy.jpg')
display.Image(filename=fn, width=200)
```

<img src="index_files/figure-commonmark/cell-21-output-1.jpeg"
width="200" />

We create a
[`Chat`](https://AnswerDotAI.github.io/cosette/core.html#chat) object as
before:

``` python
chat = Chat(model)
```

Claudia expects images as a list of bytes, so we read in the file:

``` python
img = fn.read_bytes()
```

Prompts to Claudia can be lists, containing text, images, or both, eg:

``` python
chat([img, "In brief, what color flowers are in this image?"])
```

The flowers in the image are purple.

<details>

- id: chatcmpl-9R8Vqpx62OezZDjAt3SIfnjMpH3I8
- choices: \[Choice(finish_reason=‘stop’, index=0, logprobs=None,
  message=ChatCompletionMessage(content=‘The flowers in the image are
  purple.’, role=‘assistant’, function_call=None, tool_calls=None))\]
- created: 1716254606
- model: gpt-4o-2024-05-13
- object: chat.completion
- system_fingerprint: fp_927397958d
- usage: CompletionUsage(completion_tokens=8, prompt_tokens=273,
  total_tokens=281)

</details>

The image is included as input tokens.

``` python
chat.use
```

    In: 273; Out: 8; Total: 281

Alternatively, Cosette supports creating a multi-stage chat with
separate image and text prompts. For instance, you can pass just the
image as the initial prompt (in which case the model will make some
general comments about what it sees), and then follow up with questions
in additional prompts:

``` python
chat = Chat(model)
chat(img)
```

What an adorable puppy! This puppy has a white and light brown coat and
is lying on green grass next to some purple flowers. Puppies like this
are commonly seen from breeds such as Cavalier King Charles Spaniels,
though without more context, it’s difficult to identify the breed
precisely. It looks very playful and cute!

<details>

- id: chatcmpl-9R8VsAnTWr9k1DShC7mZsnhRtqxRA
- choices: \[Choice(finish_reason=‘stop’, index=0, logprobs=None,
  message=ChatCompletionMessage(content=“What an adorable puppy! This
  puppy has a white and light brown coat and is lying on green grass
  next to some purple flowers. Puppies like this are commonly seen from
  breeds such as Cavalier King Charles Spaniels, though without more
  context, it’s difficult to identify the breed precisely. It looks very
  playful and cute!”, role=‘assistant’, function_call=None,
  tool_calls=None))\]
- created: 1716254608
- model: gpt-4o-2024-05-13
- object: chat.completion
- system_fingerprint: fp_927397958d
- usage: CompletionUsage(completion_tokens=63, prompt_tokens=262,
  total_tokens=325)

</details>

``` python
chat('What direction is the puppy facing?')
```

The puppy is facing slightly to the right of the camera, with its head
turned towards the viewer. Its body is positioned in such a way that
suggests it is laying down or resting on the grass.

<details>

- id: chatcmpl-9R8VuzGIABwg341oOHMXbGGa7daya
- choices: \[Choice(finish_reason=‘stop’, index=0, logprobs=None,
  message=ChatCompletionMessage(content=‘The puppy is facing slightly to
  the right of the camera, with its head turned towards the viewer. Its
  body is positioned in such a way that suggests it is laying down or
  resting on the grass.’, role=‘assistant’, function_call=None,
  tool_calls=None))\]
- created: 1716254610
- model: gpt-4o-2024-05-13
- object: chat.completion
- system_fingerprint: fp_927397958d
- usage: CompletionUsage(completion_tokens=40, prompt_tokens=340,
  total_tokens=380)

</details>

``` python
chat('What color is it?')
```

The puppy has a predominantly white coat with light brown patches,
particularly around its ears and eyes. This coloration is commonly seen
in certain breeds, such as the Cavalier King Charles Spaniel.

<details>

- id: chatcmpl-9R8Vwtlu6aDEGQ8O7bZFk8rfT9FGL
- choices: \[Choice(finish_reason=‘stop’, index=0, logprobs=None,
  message=ChatCompletionMessage(content=‘The puppy has a predominantly
  white coat with light brown patches, particularly around its ears and
  eyes. This coloration is commonly seen in certain breeds, such as the
  Cavalier King Charles Spaniel.’, role=‘assistant’, function_call=None,
  tool_calls=None))\]
- created: 1716254612
- model: gpt-4o-2024-05-13
- object: chat.completion
- system_fingerprint: fp_927397958d
- usage: CompletionUsage(completion_tokens=38, prompt_tokens=393,
  total_tokens=431)

</details>

Note that the image is passed in again for every input in the dialog, so
that number of input tokens increases quickly with this kind of chat.

``` python
chat.use
```

    In: 995; Out: 141; Total: 1136</doc></docs><api><doc title="API List" desc="A succint list of all functions and methods in claudette.">404: Not Found</doc></api><optional><doc title="Tool loop handling" desc="How to use the tool loop functionality for complex multi-step interactions"># Tool loop



``` python
model = models[0]
```

``` python
orders = {
    "O1": dict(id="O1", product="Widget A", quantity=2, price=19.99, status="Shipped"),
    "O2": dict(id="O2", product="Gadget B", quantity=1, price=49.99, status="Processing"),
    "O3": dict(id="O3", product="Gadget B", quantity=2, price=49.99, status="Shipped")}

customers = {
    "C1": dict(name="John Doe", email="john@example.com", phone="123-456-7890",
               orders=[orders['O1'], orders['O2']]),
    "C2": dict(name="Jane Smith", email="jane@example.com", phone="987-654-3210",
               orders=[orders['O3']])
}
```

``` python
def get_customer_info(
    customer_id:str # ID of the customer
): # Customer's name, email, phone number, and list of orders
    "Retrieves a customer's information and their orders based on the customer ID"
    print(f'- Retrieving customer {customer_id}')
    return customers.get(customer_id, "Customer not found")

def get_order_details(
    order_id:str # ID of the order
): # Order's ID, product name, quantity, price, and order status
    "Retrieves the details of a specific order based on the order ID"
    print(f'- Retrieving order {order_id}')
    return orders.get(order_id, "Order not found")

def cancel_order(
    order_id:str # ID of the order to cancel
)->bool: # True if the cancellation is successful
    "Cancels an order based on the provided order ID"
    print(f'- Cancelling order {order_id}')
    if order_id not in orders: return False
    orders[order_id]['status'] = 'Cancelled'
    return True
```

``` python
tools = [get_customer_info, get_order_details, cancel_order]
chat = Chat(model, tools=tools)
```

``` python
r = chat('Can you tell me the email address for customer C2?')
```

    - Retrieving customer C2

``` python
choice = r.choices[0]
print(choice.finish_reason)
choice
```

    tool_calls

    Choice(finish_reason='tool_calls', index=0, logprobs=None, message=ChatCompletionMessage(content=None, role='assistant', function_call=None, tool_calls=[ChatCompletionMessageToolCall(id='call_BYev4ExQk899v9yjLERyDGSc', function=Function(arguments='{"customer_id":"C2"}', name='get_customer_info'), type='function')]))

``` python
r = chat()
r
```

The email address for customer C2 (Jane Smith) is jane@example.com.

<details>

- id: chatcmpl-9R81d5i8pBSIRg5B7erJcF8t5BzKw
- choices: \[Choice(finish_reason=‘stop’, index=0, logprobs=None,
  message=ChatCompletionMessage(content=‘The email address for customer
  C2 (Jane Smith) is jane@example.com.’, role=‘assistant’,
  function_call=None, tool_calls=None))\]
- created: 1716252733
- model: gpt-4o-2024-05-13
- object: chat.completion
- system_fingerprint: fp_729ea513f7
- usage: CompletionUsage(completion_tokens=17, prompt_tokens=251,
  total_tokens=268)

</details>

``` python
chat = Chat(model, tools=tools)
r = chat('Please cancel all orders for customer C1 for me.')
print(r.choices[0].finish_reason)
find_block(r)
```

    - Retrieving customer C1
    tool_calls

    ChatCompletionMessage(content=None, role='assistant', function_call=None, tool_calls=[ChatCompletionMessageToolCall(id='call_lENp0aVeTJ7W0q8SRgC7h5s9', function=Function(arguments='{"customer_id":"C1"}', name='get_customer_info'), type='function')])

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/cosette/blob/main/cosette/toolloop.py#L16"
target="_blank" style="float:right; font-size:smaller">source</a>

### Chat.toolloop

>  Chat.toolloop (pr, max_steps=10, trace_func:Optional[<built-
>                     infunctioncallable>]=None, cont_func:Optional[<built-
>                     infunctioncallable>]=<function noop>, audio:Optional[ChatC
>                     ompletionAudioParam]|NotGiven=NOT_GIVEN,
>                     frequency_penalty:Optional[float]|NotGiven=NOT_GIVEN, func
>                     tion_call:completion_create_params.FunctionCall|NotGiven=N
>                     OT_GIVEN, functions:Iterable[completion_create_params.Func
>                     tion]|NotGiven=NOT_GIVEN,
>                     logit_bias:Optional[Dict[str,int]]|NotGiven=NOT_GIVEN,
>                     logprobs:Optional[bool]|NotGiven=NOT_GIVEN,
>                     max_completion_tokens:Optional[int]|NotGiven=NOT_GIVEN,
>                     max_tokens:Optional[int]|NotGiven=NOT_GIVEN,
>                     metadata:Optional[Dict[str,str]]|NotGiven=NOT_GIVEN, modal
>                     ities:Optional[List[ChatCompletionModality]]|NotGiven=NOT_
>                     GIVEN, n:Optional[int]|NotGiven=NOT_GIVEN,
>                     parallel_tool_calls:bool|NotGiven=NOT_GIVEN, prediction:Op
>                     tional[ChatCompletionPredictionContentParam]|NotGiven=NOT_
>                     GIVEN,
>                     presence_penalty:Optional[float]|NotGiven=NOT_GIVEN, reaso
>                     ning_effort:ChatCompletionReasoningEffort|NotGiven=NOT_GIV
>                     EN, response_format:completion_create_params.ResponseForma
>                     t|NotGiven=NOT_GIVEN,
>                     seed:Optional[int]|NotGiven=NOT_GIVEN, service_tier:"Optio
>                     nal[Literal['auto','default']]|NotGiven"=NOT_GIVEN,
>                     stop:Union[Optional[str],List[str]]|NotGiven=NOT_GIVEN,
>                     store:Optional[bool]|NotGiven=NOT_GIVEN, stream:Optional[L
>                     iteral[False]]|Literal[True]|NotGiven=NOT_GIVEN, stream_op
>                     tions:Optional[ChatCompletionStreamOptionsParam]|NotGiven=
>                     NOT_GIVEN, temperature:Optional[float]|NotGiven=NOT_GIVEN,
>                     tool_choice:ChatCompletionToolChoiceOptionParam|NotGiven=N
>                     OT_GIVEN, tools:Iterable[ChatCompletionToolParam]|NotGiven
>                     =NOT_GIVEN, top_logprobs:Optional[int]|NotGiven=NOT_GIVEN,
>                     top_p:Optional[float]|NotGiven=NOT_GIVEN,
>                     user:str|NotGiven=NOT_GIVEN,
>                     extra_headers:Headers|None=None,
>                     extra_query:Query|None=None, extra_body:Body|None=None,
>                     timeout:float|httpx.Timeout|None|NotGiven=NOT_GIVEN)

*Add prompt `pr` to dialog and get a response from the model,
automatically following up with `tool_use` messages*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>pr</td>
<td></td>
<td></td>
<td>Prompt to pass to model</td>
</tr>
<tr>
<td>max_steps</td>
<td>int</td>
<td>10</td>
<td>Maximum number of tool requests to loop through</td>
</tr>
<tr>
<td>trace_func</td>
<td>Optional</td>
<td>None</td>
<td>Function to trace tool use steps (e.g <code>print</code>)</td>
</tr>
<tr>
<td>cont_func</td>
<td>Optional</td>
<td>noop</td>
<td>Function that stops loop if returns False</td>
</tr>
<tr>
<td>audio</td>
<td>Optional[ChatCompletionAudioParam] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>frequency_penalty</td>
<td>Optional[float] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>function_call</td>
<td>completion_create_params.FunctionCall | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>functions</td>
<td>Iterable[completion_create_params.Function] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>logit_bias</td>
<td>Optional[Dict[str, int]] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>logprobs</td>
<td>Optional[bool] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>max_completion_tokens</td>
<td>Optional[int] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>max_tokens</td>
<td>Optional[int] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>metadata</td>
<td>Optional[Dict[str, str]] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>modalities</td>
<td>Optional[List[ChatCompletionModality]] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>n</td>
<td>Optional[int] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>parallel_tool_calls</td>
<td>bool | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>prediction</td>
<td>Optional[ChatCompletionPredictionContentParam] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>presence_penalty</td>
<td>Optional[float] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>reasoning_effort</td>
<td>ChatCompletionReasoningEffort | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>response_format</td>
<td>completion_create_params.ResponseFormat | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>seed</td>
<td>Optional[int] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>service_tier</td>
<td>Optional[Literal[‘auto’, ‘default’]] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>stop</td>
<td>Union[Optional[str], List[str]] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>store</td>
<td>Optional[bool] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>stream</td>
<td>Optional[Literal[False]] | Literal[True] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>stream_options</td>
<td>Optional[ChatCompletionStreamOptionsParam] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>temperature</td>
<td>Optional[float] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>tool_choice</td>
<td>ChatCompletionToolChoiceOptionParam | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>tools</td>
<td>Iterable[ChatCompletionToolParam] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>top_logprobs</td>
<td>Optional[int] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>top_p</td>
<td>Optional[float] | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>user</td>
<td>str | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
<tr>
<td>extra_headers</td>
<td>Headers | None</td>
<td>None</td>
<td></td>
</tr>
<tr>
<td>extra_query</td>
<td>Query | None</td>
<td>None</td>
<td></td>
</tr>
<tr>
<td>extra_body</td>
<td>Body | None</td>
<td>None</td>
<td></td>
</tr>
<tr>
<td>timeout</td>
<td>float | httpx.Timeout | None | NotGiven</td>
<td>NOT_GIVEN</td>
<td></td>
</tr>
</tbody>
</table>

<details open class="code-fold">
<summary>Exported source</summary>

``` python
@patch
@delegates(Completions.create)
def toolloop(self:Chat,
             pr, # Prompt to pass to model
             max_steps=10, # Maximum number of tool requests to loop through
             trace_func:Optional[callable]=None, # Function to trace tool use steps (e.g `print`)
             cont_func:Optional[callable]=noop, # Function that stops loop if returns False
             **kwargs):
    "Add prompt `pr` to dialog and get a response from the model, automatically following up with `tool_use` messages"
    r = self(pr, **kwargs)
    for i in range(max_steps):
        ch = r.choices[0]
        if ch.finish_reason!='tool_calls': break
        if trace_func: trace_func(r)
        r = self(**kwargs)
        if not (cont_func or noop)(self.h[-2]): break
    if trace_func: trace_func(r)
    return r
```

</details>

``` python
chat = Chat(model, tools=tools)
r = chat.toolloop('Please cancel all orders for customer C1 for me.', trace_func=print)
r
```

    - Retrieving customer C1
    ChatCompletion(id='chatcmpl-9R81fvatrbbrAuUjZRTPKWgntsRCx', choices=[Choice(finish_reason='tool_calls', index=0, logprobs=None, message=ChatCompletionMessage(content=None, role='assistant', function_call=None, tool_calls=[ChatCompletionMessageToolCall(id='call_Yss1rLc1tU2wDkWPMGSGgdor', function=Function(arguments='{"customer_id":"C1"}', name='get_customer_info'), type='function')]))], created=1716252735, model='gpt-4o-2024-05-13', object='chat.completion', system_fingerprint='fp_729ea513f7', usage=In: 157; Out: 17; Total: 174)
    - Cancelling order O1
    - Cancelling order O2
    ChatCompletion(id='chatcmpl-9R81gjtdy8L3cUI4o46MDeeOdaaRb', choices=[Choice(finish_reason='tool_calls', index=0, logprobs=None, message=ChatCompletionMessage(content=None, role='assistant', function_call=None, tool_calls=[ChatCompletionMessageToolCall(id='call_4AIzkbEYXTGNqd6uMsPLuVEB', function=Function(arguments='{"order_id": "O1"}', name='cancel_order'), type='function'), ChatCompletionMessageToolCall(id='call_Px4E3w1qEJZCIrU5ymf6qsNt', function=Function(arguments='{"order_id": "O2"}', name='cancel_order'), type='function')]))], created=1716252736, model='gpt-4o-2024-05-13', object='chat.completion', system_fingerprint='fp_729ea513f7', usage=In: 283; Out: 48; Total: 331)
    ChatCompletion(id='chatcmpl-9R81hQpOI0m1ExNidpdMrIiMx78pd', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='Both orders for customer C1 have been successfully canceled.', role='assistant', function_call=None, tool_calls=None))], created=1716252737, model='gpt-4o-2024-05-13', object='chat.completion', system_fingerprint='fp_729ea513f7', usage=In: 347; Out: 12; Total: 359)

Both orders for customer C1 have been successfully canceled.

<details>

- id: chatcmpl-9R81hQpOI0m1ExNidpdMrIiMx78pd
- choices: \[Choice(finish_reason=‘stop’, index=0, logprobs=None,
  message=ChatCompletionMessage(content=‘Both orders for customer C1
  have been successfully canceled.’, role=‘assistant’,
  function_call=None, tool_calls=None))\]
- created: 1716252737
- model: gpt-4o-2024-05-13
- object: chat.completion
- system_fingerprint: fp_729ea513f7
- usage: CompletionUsage(completion_tokens=12, prompt_tokens=347,
  total_tokens=359)

</details>

``` python
chat.toolloop('What is the status of order O2?')
```

    - Retrieving order O2

The status of order O2 is “Cancelled”.

<details>

- id: chatcmpl-9R81inXsiw5xzoux1xw5Z7bBoPsuN
- choices: \[Choice(finish_reason=‘stop’, index=0, logprobs=None,
  message=ChatCompletionMessage(content=‘The status of order O2 is
  “Cancelled”.’, role=‘assistant’, function_call=None,
  tool_calls=None))\]
- created: 1716252738
- model: gpt-4o-2024-05-13
- object: chat.completion
- system_fingerprint: fp_729ea513f7
- usage: CompletionUsage(completion_tokens=11, prompt_tokens=436,
  total_tokens=447)

</details></doc></optional></project>
