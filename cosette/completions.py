# AUTOGENERATED! DO NOT EDIT! File to edit: ../02_completions.ipynb.

# %% auto 0
__all__ = ['empty', 'models', 'text_only_models', 'has_streaming_models', 'has_sp_models', 'has_temp_models', 'can_stream',
           'can_set_sp', 'can_set_temp', 'usage', 'wrap_latex', 'mk_msg', 'mk_msgs', 'Client', 'mk_tool_choice',
           'mk_openai_func', 'call_func_openai', 'mk_toolres', 'Chat']

# %% ../02_completions.ipynb
from fastcore import imghdr
from fastcore.utils import *
from fastcore.meta import delegates

import inspect, typing, mimetypes, base64, json, ast
from typing import Callable, Any
from collections import abc
from random import choices
from string import ascii_letters,digits

from toolslm.funccall import *

from openai import types
from openai import OpenAI,NOT_GIVEN,AzureOpenAI
from openai.resources import chat
from openai.types.chat.chat_completion import ChatCompletion, Choice, CompletionUsage
from openai.resources.chat.completions.completions import Completions
from openai.types.chat.chat_completion_message_function_tool_call import ChatCompletionMessageFunctionToolCall

# %% ../02_completions.ipynb
empty = inspect.Parameter.empty

# %% ../02_completions.ipynb
models = 'gpt-5', 'gpt-5-mini', 'gpt-5-nano', 'o1-preview', 'o1-mini', 'gpt-4o', 'gpt-4o-mini', 'gpt-4-turbo', 'gpt-4', 'gpt-4-32k', 'gpt-3.5-turbo', 'gpt-3.5-turbo-instruct', 'o1', 'o3-mini', 'chatgpt-4o-latest', 'o1-pro', 'o3', 'o4-mini', 'gpt-4.1', 'gpt-4.1-mini', 'gpt-4.1-nano'

# %% ../02_completions.ipynb
text_only_models = 'o1-preview', 'o1-mini', 'o3-mini'

# %% ../02_completions.ipynb
has_streaming_models = set(models) - set(('o1-mini', 'o3-mini'))
has_sp_models = set(models) - set(('o1-mini', 'o3-mini'))
has_temp_models = set(models) - set(('o1', 'o1-mini', 'o3-mini'))

# %% ../02_completions.ipynb
def can_stream(m): return m in has_streaming_models
def can_set_sp(m): return m in has_sp_models
def can_set_temp(m): return m in has_temp_models

# %% ../02_completions.ipynb
@patch
def _repr_markdown_(self:ChatCompletion):
    det = '\n- '.join(f'{k}: {v}' for k,v in dict(self).items())
    res = self.choices
    if not res: return f"- {det}"
    return f"""{res[0].message.content}

<details>

- {det}

</details>"""

# %% ../02_completions.ipynb
def usage(inp=0, # Number of prompt tokens
          out=0  # Number of completion tokens
         ):
    "Slightly more concise version of `CompletionUsage`."
    return CompletionUsage(completion_tokens=out, prompt_tokens=inp, total_tokens=inp+out, input_tokens_details={'cached_tokens':0}, prompt_tokens_details={'cached_tokens':0})

# %% ../02_completions.ipynb
@patch
def __repr__(self:CompletionUsage): return f'In: {self.prompt_tokens}; Out: {self.completion_tokens}; Total: {self.total_tokens}'

# %% ../02_completions.ipynb
@patch
def __add__(self:CompletionUsage, b):
    "Add together each of `input_tokens` and `output_tokens`"
    return usage(self.prompt_tokens+b.prompt_tokens, self.completion_tokens+b.completion_tokens)

# %% ../02_completions.ipynb
def wrap_latex(text):
    "Replace OpenAI LaTeX codes with markdown-compatible ones"
    text = re.sub(r"\\\((.*?)\\\)", lambda o: f"${o.group(1)}$", text)
    res = re.sub(r"\\\[(.*?)\\\]", lambda o: f"$${o.group(1)}$$", text, flags=re.DOTALL)
    return res

# %% ../02_completions.ipynb
def mk_msg(msg: Union[str, ChatCompletion, dict], role: str = "user") -> dict:
    """Convert various message types to OpenAI API message format."""
    if isinstance(msg, str):
        return {"role": role, "content": msg}
    elif isinstance(msg, ChatCompletion):
        return msg.choices[0].message.model_dump(exclude_none=True)
    elif isinstance(msg, dict):
        return msg
    else:
        raise ValueError(f"Unknown msg type: {type(msg).__name__}")
    
def mk_msgs(msgs: Union[str, list]) -> list:
    """Convert string or list to formatted messages with alternating roles."""
    if isinstance(msgs, str): 
        msgs = [msgs]
    return [mk_msg(o, ('user', 'assistant')[i % 2]) for i, o in enumerate(msgs)]

# %% ../02_completions.ipynb
class Client:
    def __init__(self, model, cli=None):
        "Basic LLM messages client."
        self.model,self.use = model,usage(0,0)
        self.c = (cli or OpenAI()).chat.completions

# %% ../02_completions.ipynb
@patch
def _r(self:Client, r):
    "Store the result of the message and accrue total usage."
    self.result = r
    if getattr(r,'usage',None): self.use += r.usage
    return r

# %% ../02_completions.ipynb
def mk_tool_choice(choice: Union[str, Callable, dict]) -> Union[str, dict[str, Any]]:
    """Returns either a string or dict suitable for tool_choice parameter."""
    if not choice or choice in ("auto", "none", "required"):
        return choice
    
    if isinstance(choice, dict):
        return choice
    
    name = choice.__name__ if callable(choice) else str(choice)
    return {
        "type": "function",
        "function": {"name": name}
    }

def mk_openai_func(f):
    """Convert a function to OpenAI tool definition for chat.completions."""
    if isinstance(f, dict): 
        return f
    
    sc = get_schema(f, 'parameters')
    if 'parameters' in sc: 
        sc['parameters'].pop('title', None)
    
    return {
        "type": "function",
        "function": sc  # Wrap schema in "function" key
    }

# %% ../02_completions.ipynb
@patch
@delegates(Completions.create)
def __call__(self:Client,
             msgs:list, # List of messages in the dialog
             sp:str='', # System prompt
             maxtok=4096, # Maximum tokens
             tools:Optional[list]=None, # List of tools to make available
             tool_choice:Optional[str]=None, # Forced tool choice
             cb:callable=None, # Callback after completion
             **kwargs):
    "Make a call to LLM."
    msgs = mk_msgs(msgs)
    tools = [mk_openai_func(o) for o in listify(tools)]
    if sp: msgs.insert(0, {"role": "developer", "content": sp})
    r = self.c.create(
        model=self.model, messages=msgs, max_completion_tokens=maxtok,
        tools=tools, tool_choice=mk_tool_choice(tool_choice), **kwargs)
    res = self._r(r)
    if cb: cb(res)
    return res

# %% ../02_completions.ipynb
def call_func_openai(func, ns:Optional[abc.Mapping]=None):
    return call_func(func.name, ast.literal_eval(func.arguments), ns, raise_on_err=True)

# %% ../02_completions.ipynb
def _toolres(r, ns):
    "Create a result dict from `tcs`."
    tcs = [o for o in r.choices[0].message.tool_calls if isinstance(o, ChatCompletionMessageFunctionToolCall)] if isinstance(r, ChatCompletion) and r.choices[0].message.tool_calls else []
    if ns is None: ns = globals()
    return { tc.id: call_func_openai(tc.function, ns=ns) for tc in tcs }

# %% ../02_completions.ipynb
def mk_toolres(
    r:abc.Mapping, # Response containing tool use request
    ns:Optional[abc.Mapping]=None # Namespace to search for tools
    ):
    "Create a `tool_result` message from response `r`."
    tr = _toolres(r, ns)
    r = mk_msg(r)
    res = [r] if isinstance(r, dict) else listify(r)
    for k,v in tr.items(): res.append(dict(role="tool", content=v if isinstance(v, list) else str(v), tool_call_id=k))
    return res

# %% ../02_completions.ipynb
@patch
@delegates(Client.__call__)
def structured(self:Client,
               msgs: list, # Prompt
               tools:Optional[list]=None, # List of tools to make available to OpenAI model
               ns:Optional[abc.Mapping]=None, # Namespace to search for tools
               **kwargs):
    "Return the value of all tool calls (generally used for structured outputs)"
    if ns is None: ns = mk_ns(tools)
    r = self(msgs, tools=tools, tool_choice='required', **kwargs)
    return first(_toolres(r, ns).values())

# %% ../02_completions.ipynb
class Chat:
    def __init__(self,
                 model:Optional[str]=None, # Model to use (leave empty if passing `cli`)
                 cli:Optional[Client]=None, # Client to use (leave empty if passing `model`)
                 sp='', # Optional system prompt
                 tools:Optional[list]=None, # List of tools to make available
                 hist: list = None,  # Initialize history
                 tool_choice:Optional[str]=None, # Forced tool choice
                 ns:Optional[abc.Mapping]=None,  # Namespace to search for tools
                 **kw):
        "OpenAI chat client."
        assert model or cli
        self.c = (cli or Client(model))
        self.h = hist if hist else []
        if ns is None: ns=tools
        self.sp,self.tools,self.tool_choice,self.ns,self.kw = sp,tools,tool_choice,ns,kw
    
    @property
    def use(self): return self.c.use

# %% ../02_completions.ipynb
@patch
@delegates(Completions.create)
def __call__(self:Chat,
             pr=None,  # Prompt / message
             tools=None, # Tools to use
             tool_choice=None, # Required tools to use
             **kwargs):
    "Add prompt `pr` to dialog and get a response"
    if isinstance(pr,str): pr = pr.strip()
    if pr: self.h.append(mk_msg(pr))
    if not tools: tools = self.tools
    if not tool_choice: tool_choice = self.tool_choice
    kw = self.kw | kwargs
    def _cb(v):
        self.last = mk_toolres(v, ns=self.ns)
        self.h += self.last
    res = self.c(self.h, sp=self.sp, cb=_cb, tools=tools, **kw)
    return res
